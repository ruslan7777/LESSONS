package com;

/**
 * Created by RUSLAN77 on  08.12.2016 in Ukraine
 * В иерархии классов часто присутствуют методы с одинаковой сигнатурой и одинаковым возвращаемым значением как в суперклассе, так и в подклассе. В этом случае говорят, что метод суперкласса переопределяется в подклассе. Если переопределяемый метод вызывается из подкласса, то он всегда будет ссылаться на версию метода, определенную в подклассе. Версия метода, определенная в суперклассе, скрывается. Рассмотрим в качестве примера следующую программу.
 * Когда метод show ( ) вызывается для объекта типа B, выбирается версия этого метода, определенная в классе B. Таким образом, версия метода show () в классе B переопределяет версию одноименного метода, объявленную в классе А.
 */

// Переопределение метода
//class A3 {
//    int i, j;
//
//    A3(int a, int b) {
//        i = a;
//        j = b;
//    }
//
//    // Отобразить переменные i и j
//    void show() {
//        System.out.println("i и j: " + i + " " + j);
//    }
//}
//
//class B3 extends A3 {
//    int k;
//
//    B3(int a, int b, int с) {
//        super(a, b);
//        k = с;
//    }
//
//    // Отображение переменной k
//    void show() { //Данный метод nepeoпpeдeляет метод show ( ) нз класса А
//
//        super.show(); /*  Добавилась только эта строка, чтобы изменить программу- для обращения к исходной версии переопределяемого класса.
//                      В данном случае super. show () - это вызов метода show (}, определенного в суперклассе.*/
//
//        System.out.println("k: " + k);
//    }
//}
//
//public class Override {
//    public static void main(String[] args) {
//        B3 subOb = new B3(1, 2, 3);
//
//        subOb.show();//вызвать метод show() из класса В
//
//    }
//}

/*Если требуется обратиться к исходной версии переопределяемого метода, т.е. той,которая определена в суперклассе, следует воспользоваться ключевым словом super.
Например, в приведенном ниже варианте класса B из метода show () вызывается версия того же метода, определенная в суперклассе. При этом отображаются все переменные
экземпляра.

class B extends А {
int k;
В (int а, int Ь, int с) {
super (а, b);
k = с;
}
void show () {
super.show();
System.out.println("k: " + k);
}
}

Если подставить новую версию метода show () в предыдущий вариант программы,
результат ее выполнения изменится и будет иметь следующий вид.
i и j: 1 2
k: 3
*/

    /*Переопределение метода происходит только в том случае, если сигнатуры переопределяемого        и переопределяющего методов совпадают. В противном случае происходит        обычная перегрузка методов. Рассмотрим следующую видоизмененную версию предыдущего        примера.*/
/* Методы с разными сигнатурами не переопределяются,  а перегружаются. */
class A3 {
    int i, j;

    A3(int a, int b) {
        i = a;
        j = b;
    }

    // Отобразить переменные i и j
    void show() {
        System.out.println("i и j: " + i + " " + j);
    }
}

class B3 extends A3 {
    int k;

    B3(int a, int b, int с) {
        super(a, b);
        k = с;
    }

    // Перегрузить метод show()
    void show(String msg) { //Сигнатуры донного метода и метода show () из класса А   отличаются, поэтому вместо переопределения происходит   перегрузка метода

        System.out.println(msg + k);
    }
}

public class Override { //Правильнее назвать класс Overload  (перегрузка)
    public static void main(String[] args) {
        B3 subOb = new B3(1, 2, 3);

        subOb.show("k: "); // вызывается метод show() из класса В
        subOb.show(); // вызывается метод show() из класса А

    }
}
/* На этот раз в версии метода show () из класса в предусмотрен строковый параметр.Из-за этого сигнатура данного метода отличается от сигнатуры метода show () из класса А, для которого параметры не предусмотрены. Поэтому никакого переопределения метода не происходит.*/