package com;

/*Нециклическая очередь не позволяет повторно использовать элементы, поэтому со временем пространство для хранения новых элементов исчерпывается.
Индекс вставки данных в очередь определяет, в какое место будет помещен следующий элемент очереди. А индекс извлечения данных указывает место, откуда
должен быть извлечен очередной элемент очереди.*/
class Queue {
    char q[];                      // массив для хранения элементов очереди
    int putloc, getloc;            // индексы для вставки (putloc) и извлечения (getloc) элементов очереди

    //Конструктор класса Queue создает очередь заданного размера:
    Queue(int size) {
        q = new char[size + 1]; // вьделить память для очереди
        putloc = getloc = 0;//  размер очереди на единицу превышает размер, задаваемый   параметром size. Особенности реализации очереди таковы, что один
    }          // элемент массива остается неиспользованным, поэтому размер массива должен быть на единицу больше размера очереди, создаваемой на его основе.

    // Метод put (), помещающий элемент в очередь:
    void put(char ch) {
        if (putloc == q.length - 1) {
            System.out.println(" - Очередь заполнена");
            return;
        }
        putloc++;
        q[putloc] = ch;
    }
         /*Прежде всего в теле данного метода проверяется, не переполнена ли очередь.Если значение переменной putloc соответствует последней позиции в массиве q, то места для размещения новых элементов в очереди нет. В противном случае переменная putloc инкрементируется, и новый элемент располагается в указанном
месте массива. Следовательно, переменная putloc всегда содержит индекс элемента, помещенного в очередь последним.*/

    // метод get () для извлечения символа из очереди
    char get() {
        if (getloc == putloc) {
            System.out.println(" - Очередь пуста");
            return (char) 0;
        }
        getloc++;
        return q[getloc];
        /*Сначала в данном методе проверяется, пуста ли очередь. Если значения индексов в переменных getloc и putloc совпадают, то в очереди нет ни одного элемента.
Именно поэтому в конструкторе Queue переменные getloc и putloc инициализируются нулевыми значениями. Если очередь не пуста, то переменная getloc
инкрементируется и из нее извлекается очередной элемент. Следовательно, переменная getloc содержит индекс последнего извлеченного элемента.*/
    }
}

class QDemo {
    public static void main(String args[]) {
        Queue bigQ = new Queue(100);
        Queue smallQ = new Queue(4);
        char ch;
        int i;
        System.out.println("Иcпoльзoвaниe очереди bigQ для сохранения алфавита");

        // Поместить буквенные символы в очередь ЬigQ
        for (i = 0; i < 26; i++)
            bigQ.put((char) ('А' + i));

        // Извлечь буквенные символы из очереди ЬigQ и отобразить
        System.out.print("Coдepжимoe очереди bigQ: ");
        for (i = 0; i < 26; i++) {
            ch = bigQ.get();
            if (ch != (char) 0) System.out.print(ch+" ");
        }

        System.out.println("\n");
        System.out.println("Иcпoльзoвaниe очереди smallQ   для генерации ошибок");
// Использовать очередь smallQ для генерации ошибок
        for (i = 0; i < 5; i++) {
            System.out.print("Пoпыткa сохранения " +
                    (char) ('z' - i));
            smallQ.put((char) ('Z' - i));
            System.out.println();
        }
        System.out.println();

        // Дополнительные ошибки при обращении к очереди smallQ
        System.out.print("Coдepжимoe smallQ: ");
        for (i = 0; i < 5; i++) {
            ch = smallQ.get();
            if (ch != (char) 0) System.out.print(ch);
        }
    }
}




