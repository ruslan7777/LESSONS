package com;

/*
 * Created by RUSLAN77 on  11.01.2017 in Ukraine
Файл открывается для ввода созданием объекта типа FilelnputStream.
Для этой цели чаще всего используется приведенная ниже форма объявления конструктора данного класса.
 FilelnputStream(String имя_файла) throws FileNotFoundException

        В качестве параметра этому конструктору передается имя_файла, который требуется открыть. Если указанный файл не существует, генерируется исключениеFileNotFoundException.

        Для чтения данных из файла служит метод read(). Ниже приведена форма объявления этого метода, которой мы будем пользоваться в дальнейшем,
        int read() throws IOException
        При каждом вызове метод read() читает байт из файла и возвращает его как целочисленное значение. По достижении конца файла этот метод возвращает значение -1. При возникновении ошибки метод генерирует исключение IOException. Как видите, в этой форме метод read() выполняет те же самые действия, что и одноименный метод для ввода данных с консоли.

        Завершив операции с файлом, следует закрыть его с помощью метода close(), общая форма объявления которого выглядит следующим образом:
        void close() throws IOException

 * Отображение текстового файла.
  * При вызове этой программы следует указать имя файла,  содержимое которого требуется просмотреть.
 * Например,для вывода на экран содержимого файла TEST.TXT,        в командной строке нужно указать следующее:        java ShowFile TEST.TXT
 */

import java.io.*;

class ShowFile {
    public static void main(String args[]) {
        int i;
        FileInputStream fin;

// Прежде всего следует убедиться, что файл был указан,
//        if (args.length != 1) {                                // Убрал проверку- программа заработала!!!
//            System.out.println("Usage: ShowFile File");
//            return;
//        }
        try {
// Открытие файла.
            fin = new FileInputStream("C://LESSONS//out//production//LESSONS//com//TEST11.txt");     //todo
            // НЕ РАБОТАЛА ПРОГРАММА!!!!!! Путь в скобках добавлял сам вместо args[]

        } catch (FileNotFoundException exc) {
            System.out.println("File Not Found");
            return;
        }
//        try {
//// читать из файла до тех пор, пока не встретится знак EOF.
//            do {
//// Чтение из файла.
//                i = fin.read();
//                if (i != -1) System.out.print((char) i);
//// Если значение переменной i равно -1,значит, достингут конец файла.
//            } while (i != -1);
//        } catch (IOException exc) {
//            System.out.println("Error reading file.");
//        }
//        try {
//// Закрытие файла.
//            fin.close();
//        } catch (IOException exc) {
//            System.out.println("Error closing file.");
//        }
//    }
//}
        try {
            do {
                i = fin.read();
                if (i != -1) System.out.print((char) i);
            } while (i != -1);
        } catch (IOException exc) {
            System.out.println("Error Reading File");
            // Блок finally используется для закрытия файла.
        } finally {
            // закрыть файл при выходе из блока try.
            try {
                fin.close();
            } catch (IOException exc) {
                System.out.println("Error Closing File");
            }
        }
    }
}

/*В приведенном выше примере поток ввода из файла закрывается после того, как чтение данных из файла завершается в блоке try. Такой способ оказывается удобным не всегда, и поэтому в Java предоставляется более совершенный и чаще употребляемый способ. А состоит он в вызове метода close() в блоке finally. В этом случае все методы, получающие доступ к файлу, помещаются в блок try, а для закрытия файла используется блок finally. Благодаря этому файл закрывается независимого от того, как завершится блок try. Если продолжить предыдущий пример, то блок try, в котором выполняется чтение из файла, можно переписать следующим образом (также скопировал в программу выше):

try {
  do {
      i = fin.read();
      if(i != -1) System.out.print((char) i) ;
  } while(i != —1) ;
} catch(IOException exc) {
  System.out.println("Error Reading File");
  // Блок finally используется для закрытия файла.
} finally {
  // закрыть файл при выходе из блока try.
  try {
    fin.close();
  } catch(IOException exc) {
    System.out.println("Error Closing File");
  }
}
Преимущество рассмотренного выше способа состоит, в частности, в том, что если программа, получающая доступ к файлу, завершается аварийно из-за какой-нибудь ошибки ввода-вывода, генерирующей исключение, файл все равно закрывается в блоке finally. И если с аварийным завершением простых программ, как в большинстве примеров в этой книге, из-за неожиданно возникающей исключительной ситуации еще можно как-то мириться, то в крупных программах подобная ситуация вряд ли вообще допустима. Именно ее и позволяет исключить блок finally.*/



/*Иногда оказывается проще заключить в оболочку те части программы, в которых открывается файл, чтобы получить доступ к нему из единственного блока try, не разделяя его на два блока, а для закрытия файла использовать отдельный блок finally. В качестве примера ниже приведена переделанная версия рассмотренной выше программы ShowFile.
/* В этой версии программы отображения текстового файла код,
открывающий файл и получающий к нему доступ, заключается
в единственный блок try. А закрывается файл в блоке finally.
import java.io.*;
class ShowFile {
    public static void main(String args[])
    {
        int i;
        FilelnputStream fin = null;

        // Прежде всего следует убедиться, что файл был указан,
        if (args.length != 1)   {
            System.out.println("Usage: ShowFile filename");
            return;
        }

        // В следующем коде открывается файл, из которого читаются
        // символы до тех пор, пока не встретится знак EOF, а затем
        // файл закрывается в блоке finally,
        try {
            fin = new FilelnputStream(args[0]);
            do {
                i = fin.read() ;
                if(i != -1) System.out.print((char) i);
            } while(i != -1);
        } catch(FileNotFoundException exc) {
            System.out.println("File Not Found.");
        } catch(IOException exc) {
            System.out.println("An I/O Error Occurred");
        } finally {
            // Файл закрывается в любом случае,
            try {
                if (fin != null) fin.closeO;
            } catch(IOException exc) {
                System.out.println("Error Closing File");
            }
        }
    }
}
Обратите внимание на то, что переменная fin инициализируется пустым значением null. А в блоке finally файл закрывается только в том случае, если значение
 переменной fin не является пустым. Такой способ оказывается вполне работоспособным, поскольку переменная fin не будет содержать пустое значение лишь
 в том случае, если файл был успешно открыт. Следовательно, метод close() не будет вызываться, если во время открытия файла возникнет исключение.
 В приведенном выше примере блок try/catch можно сделать более компактным. Ведь исключение FileNotFoundException является подклассом исключения IOException, и поэтому его не нужно перехватывать отдельно. В качестве примера ниже приведен блок оператора catch, которым можно воспользоваться для перехвата обоих этих исключений, не прибегая к перехвату исключения FileNotFoundException в отдельности. В данном случае выводится стандартное сообщение о возникшем исключении с описанием характера ошибки.
..........
 catch(IOException ехс) {
System.out.println("Owибкa ввода-вывода: " + ехс);
finally
........
 */