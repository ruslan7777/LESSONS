package com;

/* Простая версия класса Quicksort, реализующего быструю сортировку. Данная версия программы работает только с символьными массивами,
но вы можете адаптировать ее для сортировки массивов любого типа. */
class Quicksort {
    // Организовать вызов фактического метода быстрой сортировки
    static void qsort(int items[]) {
        qs(items, 0, items.length - 1);
    }

    //
    //todo
    //Рекурсивная версия метода быстрой сортировки символов
    //
    private static void qs(int items[], int left, int right) {
        int i = left, j = right;
        int x, y;
        x = items[(left + right) / 2];

        do {
            while ((items[i] < x) && (i < right)) i++;
            while ((x < items[j]) && (j > left)) j--;

            if ((i <= j)) {
                y = items[i];
                items[i] = items[j];
                items[j] = y;
                i++;
                j--;
            }
        } while (i <= j);
        if (left < j) qs(items, left, j);
        if (i < right) qs(items, i, right);
/*С целью упрощения интерфейса в классе Quicksort предоставляется метод qsort (), из которого вызывается метод qs (), фактически выполняющий сортировку.
Такой подход позволяет выполнять сортировку, передавая методу лишь имя массива и не осуществляя первоначальное разделение. А поскольку метод qs ()
используется только в классе, он определяется как private.*/
    }
}

public class QSDemo {
    public static void main(String[] args) {
        int a[] = {7, 3, 2, 6, 5, 4, 1};
        int i;
        System.out.print("Иcxoдный массив: ");
        for (i = 0; i < a.length; i++)
            System.out.print(a[i]);
        System.out.println();

// Отсортировать массив
        Quicksort.qsort(a);
        System.out.print("Oтcopтиpoвaнный массив: ");
        for (i = 0; i < a.length; i++)
            System.out.print(a[i]);
    }
}

/*
 * Быстрая сортировка опирается на принцип разделения. Сначала из массива выбирается один опорный элемент (так называемый компаранд), и массив делится на две части.
 * Элементы, "меньшие" опорного, помещаются в одну часть массива, а "большие или равные опорному", - в другую часть. Затем процесс рекурсивно повторяется для
 * каждой оставшейся части до тех пор, пока массив не окажется отсортированным. Допустим, имеется массив, содержащий последовательность символов fedacb, а
 * в качестве  опорного выбран символ d. На первом проходе массив будет частично упорядочен следующим образом:
 Исходные данные fedacb
 Проход 1 bcadef
 * Далее этот процесс повторяется для каждой части: Ьса и def. Как видите, процесс рекурсивен по своей сути, и действительно, наиболее эффективной реализацией быстрой сортировки является рекурсивная сортировка.*/
