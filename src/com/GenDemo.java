package com;

/**
 * Created by RUSLAN77 on  08.02.2017 in Ukraine
 * <p>
 * Прежде чем приступать к более подробному рассмотрению обобщений, полезно рассмотреть простой пример их применения. Ниже приведен исходный код программы, в которой объявлены два класса. Первым из них является обобщенный класс Gen, вторым — класс GenDemo, в котором используется класс Gen.
 */

// Простой обобщенный класс.
// Здесь Т - это параметр типа, заменяемый именем подлинного типа при создании объекта класса Gen.

//В объявлении этого класса Т означает обобщенный тип.
class Gen<T> {
    T ob; // объявить объект типа Т

    // передать конструктору ссылку на объект типа Т.
    Gen(T о) {
        ob = о;
    }

    // возвратить объект ob из метода
    T getob() {
        return ob;
    }

    // отобразить тип Т
    void showType() {
        System.out.println("Type of T is " + ob.getClass().getName());
    }
}

// продемонстрировать обобщенный класс
class GenDemo {
    public static void main(String args[]) {

        // Создание ссылки на объект типа Gen<Integer>.
        Gen<Integer> iOb;

        // Создать объект типа Gen<Integer> и присвоить ссылку на него переменной iOb. Обратите внимание на автоупаковку при инкапсуляции значения 88
        // в объекте типа Integer.
        iOb = new Gen<Integer>(88); // получить экземпляр типа Gen<Integer>

        // отобразить тип данных, используемых в объекте iOb
        iOb.showType();

        // Получение значения из объекта iOb. Обратите внимание на то,что приведение типов здесь не требуется,
        int v = iOb.getob();
        System.out.println("value: " + v);

        System.out.println();

        // Создание объекта типа Gen для символьных строк. Здесь создается ссылка и сам объект типа Gen<String>.
        Gen<String> strOb = new Gen<String>("Generics Test");

        // отобразить тип данных, используемых в объекте strOb
        strOb.showType();

        // Получение значения из объекта strOb.И здесь приведение типов не требуется.
        String str = strOb.getob();
        System.out.println("value: " + str);
    }
}

/*Рассмотрим исходный код данной программы более подробно.
 Прежде всего обратите внимание на то, как объявляется класс Gen. Для этого используется следующая строка кода:
class Gen<T> {
где Т — имя параметра типа. Это имя служит в качестве метки-заполнителя конкретного типа, который указывается при создании объекта класса Gen. Следовательно, имя T используется в классе Gen всякий раз, когда требуется параметр типа. Обратите внимание на то, что имя T заключается в угловые скобки (< >). Этот синтаксис можно обобщить: всякий раз, когда объявляется параметр типа, он указывается в угловых скобках. А поскольку параметр типа используется в классе Gen, то такой класс считается обобщенным.В объявлении класса Gen можно указывать любое имя параметра типа, но по традиции выбирается имя Т. К числу других наиболее употребительных имен параметров типа относятся V и Е. А вообще, обозначать параметры типа рекомендуется одной прописной буквой.

Далее имя T используется для объявления объекта ob, как показано в следующей строке кода:
Т ob; // объявить объект типа Т
Как пояснялось выше, имя параметра типа T служит меткой-заполнителем конкретного типа, указываемого при создании объекта класса Gen. Поэтому объект ob будет иметь тип, передаваемый в качестве параметра типа T при получении экземпляра объекта класса Gen. Так, если качестве параметра типа Т указывается String, то экземпляр объекта оЪ будет отнесен к типу String.

Рассмотрим далее конструктор класса Gen.
Gen(Т о) {
    ob = о;
}
Как видите, параметр о этого конструктора относится к типу Т. Это означает, что конкретный тип параметра о определяется типом, передаваемым в качестве параметра типа Т при создании объекта класса Gen. А поскольку параметр о и переменная экземпляра ob относятся к типу Т, то после создания объекта класса Gen их конкретный тип окажется одним и тем же.

С помощью параметра типа T можно также указывать тип, возвращаемый методом, как показано ниже на примере метода getob().
Т getob() {
    return ob;
}
Переменная экземпляра ob также относится к типу T, поэтому ее тип совпадает с типом, возвращаемым методом getob().

Метод showType() отображает тип Т. С этой целью метод getName() вызывается для объекта типа Class, возвращаемого методом getClass(), вызываемым для объекта ob. Это средство еще не применялось в представленных до сих пор примерах программ, поэтому рассмотрим его подробнее. Как пояснялось в главе 7, в классе Object определен метод getClass(), автоматически являющийся членом каждого производного класса. Он возвращает объект типа Class, соответствующий типу класса текущего объекта. Класс Class относится к пакету java.lang и инкапсулирует сведения о текущем классе. В нем определено несколько методов, которые позволяют получать сведения о классах по ходу выполнения программы. К их числу принадлежит метод getName(), возвращающий строковое представление имени класса.

В классе Gen Demo демонстрируется применение обобщенного класса Gen. Прежде всего, в нем создается версия класса Gen для целых чисел, как показано ниже.
Gen<Integer> iOb;
Внимательно проанализируем это объявление. В первую очередь обратите внимание на то, что тип Integer указывается в угловых скобках после имени класса Gen. В данном случае Integer служит аргументом типа, передаваемым в качестве параметра типа Т класса Gen. В рассматриваемом здесь объявлении создается версия класса Gen, в которой тип Т заменяется типом Integer везде, где он встречается. Следовательно, после этого объявления Integer становится типом переменной ob и возвращаемым типом метода getob().

Прежде чем продолжить рассмотрение обобщений, следует принять во внимание то обстоятельство, что компилятор Java на самом деле не создает разные версии Gen или другого обобщенного класса, а просто удаляет данные обобщенного типа, заменяя их приведением типов. Получаемый в итоге объект ведет себя так, как будто в программе была создана конкретная версия класса Gen. Таким образом, в программе фактически присутствует лишь одна версия класса Gen. Процесс удаления данных обобщенного типа называется стиранием, более подробно рассматриваемым в конце этой главы.

В следующей строке кода переменной iOb присваивается ссылка на экземпляр в версии класса Gen для типа Integer:
iOb = new Gen<Integer>(88);
Обратите внимание на то, что при вызове конструктора класса Gen указывается также аргумент типа Integer. Это необходимо потому, что тип объекта, на который указывает ссылка (в данном случае — iOb), должен соответствовать Gen. Если тип ссылки, возвращаемой оператором new, будет отличаться от Gen, возникнет ошибка при компиляции. Сообщение о такой ошибке будет, например, получено при попытке скомпилировать следующую строку кода:
iOb = new Gen<Double>(88.0); // Ошибка!
Переменная iOb относится к типу Gen, а следовательно, ее нельзя использовать для хранения ссылки на объект типа Gen. Возможность проверки на соответствие типов — одно из основных преимуществ обобщенных типов, поскольку они обеспечивают типовую безопасность.

Как следует из комментариев к программе, в рассматриваемом здесь операторе присваивания
iOb = new Gen<Integer>(88);
производится автоупаковка целочисленного значения 88 в объект типа Integer. Это происходит потому, что обобщение Gen создает конструктор, которому передается аргумент типа Integer. А поскольку предполагается создание объекта типа Integer, то в нем автоматически упаковывается целочисленное значение 88. Разумеется, это можно было бы явно указать в операторе присваивания, как показано ниже.

iOb = new Gen<Integer>(new Integer(88));
Но в данном случае столь длинная строка кода не дает никаких преимуществ по сравнению с предыдущей, более компактной записью.

Затем в программе отображается тип переменной ob в объекте iOb (в данном случае это тип Integer). А значение переменной ob получается в следующей строке кода:
int v = iOb.getobO;
Метод getob() возвращает значение типа Т, замененное на Integer при объявлении переменной ссылки на объект iOb, а следовательно, метод getob() фактически возвращает значение того же самого типа Integer. Это значение автоматически распаковывается перед присваиванием переменной v типа int.

И наконец, в классе GenDemo объявляется объект типа Gen.
Gen<String> strOb = new Gen<String>("Generics Test");
В этом объявлении указывается аргумент типа String, поэтому в объекте класса Gen вместо Т подставляется тип String. В итоге создается версия класса Gen для типа String, как демонстрируют остальные строки кода рассматриваемой здесь программы.*/