package com;

/*
 Как указано в комментариях к выполняющейся части программы, переменная num
 не изменяется и может быть использована в теле myLamЬda. Поэтому в результате выполнения
 инструкции println () выводится число 18. При вызове func () с аргументом 8
 значение v внутри лямбды устанавливается равным сумме num (значение 10) и значения,
 переданного параметру n (которое равно 8). Следовательно, func () возвращает число
 18. Этот механизм работает, поскольку переменная num не изменяет своего значения после
 инициализации. Но если бы значение num было изменено - будь-то в лямбда-выражении
 или вне его, - переменная num потеряла бы свой статус неизменной (final)
 переменной . Это породило бы ошибку, препятствующую компиляции программы.
 Важно подчеркнуть, что лямбда-выражение может использовать и изменять переменную
 экземпляра класса, в котором оно содержится. Не допускается лишь использование
 тех локальных переменных в области видимости, охватывающей лямбда-выражение,
 значения которых подвергаются изменениям.
 */

// Пример захвата локальной переменной из охватывающей
// лямбда-выражение области видимости
interface MyFunc {
    int func(int n);
}

class VarCapture {
    public static void main(String args[]) {
// локальная переменная, которая может быть захвачена
        int num = 10;
        MyFunc myLamЬda = (n) -> {
// Такое использование переменной num корректно, поскольку ее значения не изменяется
            int v = num + n;
// Приведенная ниже инструкция некорректна, поскольку она изменяет значение переменной num
// num++;
            return v;
        };
// Использование лямбды. Эта инструкция отобразит число 18.
        System.out.println(myLamЬda.func(8));
// Приведенная ниже строка породила бы ошибку, поскольку она лишает num статуса финальной переменной
// num = 9;
    }
}


