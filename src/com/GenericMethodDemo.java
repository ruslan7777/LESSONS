package com;


/**
 * Created by RUSLAN77 on  22.02.2017 in Ukraine
 * // Пример простого обобщенного метода
 * Ниже приведен пример программы, в которой объявляется класс GenericMethodDemo, не являющийся обобщенным. В этом классе объявляется статический обобщенный метод arraysEqualO, в котором определяется, содержатся ли в двух массивах одинаковые элементы, расположенные в том ж самом порядке. Такой метод можно использовать для сравнения двух массивов одинаковых или совместимых между собой типов.
 */
public class GenericMethodDemo {

    // Определить, совпадает ли содержимое двух массивов
    static <T extends Comparable<T>, V extends T> boolean
    arraysEqual(T[] x, V[] y) {  //Обобщенный метод

        // Если массивы имеют разную длину, они не могут быть одинаковыми,
        if (x.length != y.length) return false;

        for (int i = 0; i < x.length; i++)
            if (!x[i].equals(y[i]))
                return false; // Массивы отличаются.
        return true; // Содержимое массивов совпадает.
    }

    public static void main(String args[]) {

        Integer nums[] = {1, 2, 3, 4, 5};
        Integer nums2[] = {1, 2, 3, 4, 5};
        Integer nums3[] = {1, 2, 7, 4, 5};
        Integer nums4[] = {1, 2, 7, 4, 5, 6};

        // Аргументы типа   T   и V неявно определяются при вызове метода.
        if (arraysEqual(nums, nums))
            System.out.println("nums equals nums");

        if (arraysEqual(nums, nums2))
            System.out.println("nums equals nums2");

        if (arraysEqual(nums, nums3))
            System.out.println("nums equals nums3");

        if (arraysEqual(nums, nums4))
            System.out.println("nums equals nums4");

        // создать массив объектов типа Double
        Double dvals[] = {1.1, 2.2, 3.3, 4.4, 5.5};

        // Следующая строка не будет скомпилирована, так как типы массивов nums и dvals не совпадают.
        // if(arraysEqual(nums, dvals))
        // System.out.println("nums equals dvals");
    }
}

/*Рассмотрим подробнее исходный код метода arraysEqual(). Посмотрите прежде всего, как он объявляется:

static <Т, V extends Т> boolean arraysEqual(Т[] х, V[] у) {
Параметры типа указываются перед возвращаемым типом. Обратите далее внимание на то, что верхней границей для типа параметра V является тип параметра Т. Таким образом, тип параметра V должен быть таким же, как и у параметра Т, или же быть его подклассом. Такая связь гарантирует, что при вызове метода arraysEqual() могут быть указаны только совместимые друг с другом параметры. И наконец, обратите внимание на то обстоятельство, что метод arraysEqual() объявлен как static, т.е. его можно вызывать независимо от любого объекта. Но обобщенные методы не обязательно должны быть статическими. В этом смысле на них не накладывается никаких ограничений.

А теперь проанализируем, каким образом метод arraysEqual() вызывается в методе main(). Для этого используется обычный синтаксис, а параметры типа не указываются. И это становится возможным потому, что типы аргументов данного метода распознаются автоматически, а типы параметров Т и V настраиваются соответствующим образом. Рассмотрим в качестве примера первый вызов метода arraysEqual():

if(arraysEqual(nums, nums))
В данном случае типом первого аргумента является Integer, который и заменяет тип параметра Т. Таким же является и тип второго аргумента, а следовательно, тип параметра V также заменяется на Integer. Следовательно, выражение для вызова метода arraysEqual() составлено правильно, и оба массива можно сравнить друг с другом.

Обратите далее внимание на следующие закомментированные строки:

// if(arraysEqual(nums, dvals))
// System.out.println("nums equals dvals");
Если удалить в них символы комментариев и попытаться скомпилировать программу, то компилятор выдаст сообщение об ошибке. Дело в том, что верхней границей для типа параметра V является тип параметра Т. Этот тип указывается после ключевого ело- ва extends, т.е. тип параметра V может быть таким же, как и у параметра т, или быть его подклассом. В данном случае типом первого аргумента рассматриваемого здесь метода является Integer, заменяющий тип параметра т, тогда как типом второго аргумента — Double, не являющийся подклассом Integer. Таким образом, вызов метода arraysEqual() оказывается недопустимым, что и приводит к ошибке при компиляции.

Синтаксис объявления метода arraysEqual() может быть обобщен. Ниже приведена общая форма объявления обобщенного метода.

<параметры_типа> возвращаемый_тип имя_метода (параметры) { // ...
Как и при вызове обычного метода, параметрытипа разделяются запятыми. В обобщенном методе их список предваряет возвращаемыйтип.*/